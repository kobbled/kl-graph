PROGRAM class_name
%NOBUSYLAMP
%COMMENT = 'graph class'
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR


%include systemlib.klt
path_default_types

--define graph types
%include graph.klt
--user graph type
graph_type_define

%include errors.klt

VAR
  this : PATH pathheader = hdr_graph, nodedata = t_graph
  visited : PATH nodedata = t_BOOL

%include errors.klh
%from strings.klh %import i_to_s

-- graph class members
%include graph.klh
%include graph.private.klh

--private

ROUTINE clear_graph
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(this)
    WHILE PATH_LEN(this) > 0 DO
		  DELETE_NODE(this,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_graph

ROUTINE clear_visited
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(visited)
    WHILE PATH_LEN(visited) > 0 DO
		  DELETE_NODE(visited,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_visited

ROUTINE reset_visited
  VAR
    i : INTEGER
  BEGIN
    FOR i=1 TO PATH_LEN(visited) DO
      visited[i].v = FALSE
    ENDFOR
  END reset_visited

ROUTINE append_adj
  VAR
    i : INTEGER
    adj : weight_edge
  BEGIN
    FOR i=1 TO ARRAY_LEN(this[nde].adj) DO
      adj = this[nde].adj[i]
      IF (UNINIT(adj[1])) THEN
        this[nde].adj[i,1] = neighbor ; this[nde].adj[i,2] = edge_weight ;
        RETURN ;
      ENDIF
    ENDFOR

    -- no free slot in adjacency list
    karelError(INVALID_INDEX,'class_name node ' + i_to_s(nde) + ' adjacency list is full.', ER_ABORT)

  END append_adj

ROUTINE DFSUtil
  VAR
    i : INTEGER
    status : INTEGER
    adj : weight_edge
  BEGIN
    vistd[nde].v = TRUE
    --add to path
    APPEND_NODE(out_pth, status)
    out_pth[PATH_LEN(out_pth)].v = nde

    i = 1
    adj = grph[nde].adj[i]
    WHILE (NOT UNINIT(adj[1])) DO
      IF (vistd[adj[1]].v = FALSE) THEN
        DFSUtil((adj[1]), grph, vistd, out_pth)
      ENDIF

      i = i + 1
      IF i > ARRAY_LEN(grph[nde].adj) THEN
        RETURN
      ENDIF

      adj = grph[nde].adj[i]
    ENDWHILE
  END DFSUtil

-- public

ROUTINE new
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    clear_graph
    clear_visited

    FOR i=1 TO no_of_verts DO
      APPEND_NODE(this,status)
      CHK_STAT(status)
      --add visited node
      APPEND_NODE(visited,status)
      visited[i].v = FALSE
      CHK_STAT(status)
    ENDFOR

    --add header information
    this.directional = directional
  END new

ROUTINE destructor
  BEGIN
    clear_graph
    clear_visited
  END destructor

ROUTINE addEdge
  BEGIN
    IF (u > PATH_LEN(this)) THEN
      karelError(INVALID_INDEX,'class_name node ' + i_to_s(u) + ' does not exist.', ER_ABORT)
    ENDIF
    IF (v > PATH_LEN(this)) THEN
      karelError(INVALID_INDEX,'class_name node ' + i_to_s(v) + ' does not exist.', ER_ABORT)
    ENDIF

    append_adj(u, v, wt)
    --directional graph
    IF NOT this.directional THEN
      append_adj(v, u, wt)
    ENDIF

  END addEdge

ROUTINE is_neighbor
  VAR
    i : INTEGER
    adj : weight_edge
  BEGIN
    i = 1
    FOR i=1 TO ARRAY_LEN(this[nde].adj) DO
      adj = this[nde].adj[i]
      IF (UNINIT(adj[1])) THEN
        RETURN(FALSE)
      ENDIF

      IF adj[1] = neighbor THEN
        RETURN(TRUE)
      ENDIF
    ENDFOR

    RETURN(FALSE)
  END is_neighbor

ROUTINE list_neighbors
  VAR
    neighbors : ARRAY[MAX_NEIGHBORS] OF INTEGER
    i : INTEGER
    adj : weight_edge
  BEGIN
    i = 1
    adj = this[nde].adj[i]
    WHILE (NOT UNINIT(adj[1])) DO
      neighbors[i] = this[nde].adj[i,1]

      i = i + 1
      IF i > ARRAY_LEN(this[nde].adj) THEN
        RETURN(neighbors)
      ENDIF

      adj = this[nde].adj[i]
    ENDWHILE

    RETURN(neighbors)
  END list_neighbors

ROUTINE DFS
  VAR
    i : INTEGER
  BEGIN
    reset_visited

    IF start_node > 0 THEN
      IF start_node > PATH_LEN(this) THEN
        karelError(INVALID_INDEX,'node ' + i_to_s(start_node) + ' is not in graph.', ER_ABORT)
      ENDIF

      IF (NOT visited[start_node].v) THEN
        DFSUtil(start_node, this, visited, pth)
      ENDIF
      
    ELSE

      FOR i=1 TO PATH_LEN(this) DO
        IF (NOT visited[i].v) THEN
          DFSUtil(i, this, visited, pth)
        ENDIF
      ENDFOR
    
    ENDIF

    -- return(out_pth)

  END DFS

ROUTINE BFS
  VAR
    i : INTEGER
    v : INTEGER
    adj : weight_edge
    status : INTEGER
  BEGIN
    IF UNINIT(start_node) OR (start_node = 0) THEN start_node = 1 ; ENDIF 

    reset_visited
    --clear queue
    i = PATH_LEN(queue)
    WHILE PATH_LEN(queue) > 0 DO
		  DELETE_NODE(queue,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE


    visited[start_node].v = TRUE
    --push first node onto queue
    APPEND_NODE(queue,status)
    queue[PATH_LEN(queue)].v = start_node

    REPEAT
      --next node from queue
      v = queue[1].v
      DELETE_NODE(queue,1,status)

      --add to path list
      APPEND_NODE(pth, status)
      pth[PATH_LEN(pth)].v = v

      --if reach goal abort
      IF (v=goal) THEN
        RETURN
      ENDIF

      --get neighbors of the popped node
      i = 1
      adj = this[v].adj[1]
      REPEAT
        --if adjacent node has not been visited 
        --add to queue
        IF (NOT visited[ adj[1] ].v) THEN
          visited[ adj[1] ].v = TRUE
          --push node on queue
          APPEND_NODE(queue,status)
          queue[PATH_LEN(queue)].v = (adj[1])
        ENDIF

        i = i + 1
        IF i > ARRAY_LEN(this[v].adj) THEN
          karelError(INVALID_INDEX,'increase MAX-NEIGHBORS in class_name', ER_ABORT)
        ENDIF

        adj = this[v].adj[i]
      --repeat until adjacency list is null
      UNTIL(UNINIT(adj[1]) )

    -- repeat until queue is empty
    UNTIL(PATH_LEN(queue) = 0)

  END BFS

BEGIN
END class_name
