PROGRAM class_name
%NOBUSYLAMP
%COMMENT = 'kd tree'
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR

%defeval BASE_CLASSNAME class_name

%include errors.klt
%include systemlib.klt
%include binary_tree.c.klt

%include binary_tree.klt

%include kd_tree.klt
define_kd_types(class_name,KDTREE_COMPARE_TYPE)

VAR
  this : PATH pathheader = HDR_BST, nodedata = T_BST
  data : PATH nodedata = KDTREE_DATA_TYPE
  traverse : PATH nodedata = t_INTEGER
  current : INTEGER
  query : PATH nodedata = T_KTQUEUE
  frm : XYZWPR

%include errors.klh
%from math.klh %import ceil, manhattan_dist, norm, norm2
%include kd_tree.klh
--include user defined members
define_kd_members(class_name)
%include kd_tree.private.klh

--private

ROUTINE clear_
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(this)
    WHILE PATH_LEN(this) > 0 DO
		  DELETE_NODE(this,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE

    this.root = 0
  END clear_

ROUTINE clear_data
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(data)
    WHILE PATH_LEN(data) > 0 DO
		  DELETE_NODE(data,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_data

ROUTINE reset_generator
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    current = 0

    i = PATH_LEN(traverse)
    WHILE PATH_LEN(traverse) > 0 DO
		  DELETE_NODE(traverse,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END reset_generator

ROUTINE clear_query
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    i = PATH_LEN(query)
    WHILE PATH_LEN(query) > 0 DO
		  DELETE_NODE(query,i,status)
      CHK_STAT(status)
      i = i - 1
	  ENDWHILE
  END clear_query

ROUTINE new_node
  VAR
    i, status : INTEGER
  BEGIN
    IF idx > PATH_LEN(this) THEN
      FOR i = PATH_LEN(this)+1 TO idx DO
        APPEND_NODE(this, status)
        this[i].left = 0
        this[i].right = 0
      ENDFOR
    ENDIF
  END new_node

ROUTINE bubblesort
  VAR
    i,j : INTEGER
    n : INTEGER
    swap : KDTREE_DATA_TYPE
  BEGIN
    n = high
    FOR i=low TO high DO
      FOR j=low TO n-1 DO
        IF comparator(list[j], list[j+1], axs) = LESS_THAN THEN
          swap = (list[j+1])
          list[j+1] = (list[j])
          list[j] = swap
        ENDIF
      ENDFOR
      n = n - 1
    ENDFOR
  END bubblesort

ROUTINE build_tree
  VAR
    mid : INTEGER
  BEGIN
    IF data_start > data_end THEN
      new_node(data_end)
      RETURN(0)
    ENDIF

    bubblesort(data, data_start, data_end, (depth MOD DIMENSIONS) + 1)
    mid = TRUNC((data_start + data_end)/2)

    IF this.root = 0 THEN
      this.root = mid
    ENDIF

    new_node(mid)
    this[mid].right = build_tree(data_start, mid-1, depth+1)
    this[mid].left = build_tree(mid+1, data_end, depth+1)

    RETURN(mid)

  END build_tree

ROUTINE inorder
  VAR
    status : INTEGER
  BEGIN
    IF idx > 0 THEN
      inorder((this[idx].left))
      APPEND_NODE(traverse, status)
      traverse[PATH_LEN(traverse)].v = idx
      inorder((this[idx].right))
    ENDIF
  END inorder

ROUTINE preorder
  VAR
    status : INTEGER
  BEGIN
    IF idx > 0 THEN
      APPEND_NODE(traverse, status)
      traverse[PATH_LEN(traverse)].v = idx
      preorder((this[idx].left))
      preorder((this[idx].right))
    ENDIF
  END preorder

ROUTINE postorder
  VAR
    status : INTEGER
  BEGIN
    IF idx > 0 THEN
      preorder((this[idx].left))
      preorder((this[idx].right))
      APPEND_NODE(traverse, status)
      traverse[PATH_LEN(traverse)].v = idx
    ENDIF
  END postorder

ROUTINE minmaxUtil
  VAR
    n1, n2 : INTEGER
  BEGIN
    -- evaluate down the left hand side of the tree if current depth
    -- is the evaluation axis
    IF (dim = (depth MOD DIMENSIONS) + 1) THEN
      SELECT mn_mx OF
        CASE(LESS_THAN):
          IF this[root].left = 0 THEN RETURN(root) ; ENDIF
          n1 = minmaxUtil((this[root].left), depth+1, dim, mn_mx)
        ELSE:
          IF this[root].right = 0 THEN RETURN(root) ; ENDIF
          n1 = minmaxUtil((this[root].right), depth+1, dim, mn_mx)
      ENDSELECT
      
      IF comparator(data[n1], data[root], dim) = mn_mx THEN
        RETURN(n1)
      ENDIF
    ENDIF

    -- If current dimension is different than evaluation axis 
    -- minimum can be anywhere in this subtree
    IF this[root].left = 0 THEN
      n1 = root
    ELSE
      n1 = minmaxUtil((this[root].left), depth+1, dim, mn_mx)
    ENDIF
    IF this[root].right = 0 THEN
      n2 = root
    ELSE
      n2 = minmaxUtil((this[root].right), depth+1, dim, mn_mx)
    ENDIF

    IF comparator(data[n1], data[n2], dim) = mn_mx THEN
      IF comparator(data[n1], data[root], dim) = mn_mx THEN
        RETURN(n1)
      ELSE
        RETURN(root)
      ENDIF
    ELSE
      IF comparator(data[n2], data[root], dim) = mn_mx THEN
        RETURN(n2)
      ELSE
        RETURN(root)
      ENDIF
    ENDIF
  END minmaxUtil

ROUTINE kNNUtil
  VAR
    dist : KDTREE_COMPARE_TYPE
    i, status : INTEGER
    inserted : BOOLEAN
  BEGIN
    IF (root = 0) THEN
      RETURN
    ENDIF
    IF (NOT inhypersphere(query[1].value, point, data[root], (depth MOD DIMENSIONS)+1)) THEN
      RETURN
    ENDIF

    dist = distance(point, data[root])
    -- append node to query list
    IF dist > 0 THEN
      i = 1
      inserted = FALSE
      WHILE((i<=PATH_LEN(query)) AND (NOT inserted)) DO
        IF dist < query[i].value THEN
          INSERT_NODE(query, i, status)
          query[i].idx = root
          query[i].value = dist
          DELETE_NODE(query, PATH_LEN(query), status)
          inserted = TRUE
        ENDIF
        i = i + 1
      ENDWHILE
    ENDIF

    -- visit subtrees is most promising order:
    IF comparator(point, data[root], (depth MOD DIMENSIONS)+1) = LESS_THAN THEN
      kNNUtil((this[root].left), depth+1, point)
      kNNUtil((this[root].right), depth+1, point)
    ELSE
      kNNUtil((this[root].right), depth+1, point)
      kNNUtil((this[root].left), depth+1, point)
    ENDIF

    RETURN

  END kNNUtil

ROUTINE rNNUtil
  VAR
    dist : KDTREE_COMPARE_TYPE
    i, status : INTEGER
    inserted : BOOLEAN
  BEGIN
    IF (root = 0) THEN
      RETURN
    ENDIF
    IF (NOT inhypersphere(query[1].value, point, data[root], (depth MOD DIMENSIONS)+1)) THEN
      RETURN
    ENDIF

    dist = distance(point, data[root])
    -- append node to query list
    IF (dist < radius) AND (dist > 0) THEN
      i = 1
      inserted = FALSE
      WHILE((i<=PATH_LEN(query)) AND (NOT inserted)) DO
        IF dist < query[i].value THEN
          INSERT_NODE(query, i, status)
          query[i].idx = root
          query[i].value = dist
          inserted = TRUE
        ENDIF
        i = i + 1
      ENDWHILE
    ENDIF

    -- visit subtrees is most promising order:
    IF comparator(point, data[root], (depth MOD DIMENSIONS)+1) = LESS_THAN THEN
      rNNUtil((this[root].left), depth+1, (radius), point)
      rNNUtil((this[root].right), depth+1, (radius), point)
    ELSE
      rNNUtil((this[root].right), depth+1, (radius), point)
      rNNUtil((this[root].left), depth+1, (radius), point)
    ENDIF

    RETURN

  END rNNUtil

--public

ROUTINE clear
  VAR
    i : INTEGER
    status : INTEGER
  BEGIN
    clear_
    clear_data
    reset_generator
    clear_query

    current = 0
  END clear

ROUTINE create
  VAR
    ret : INTEGER
    status : INTEGER
  BEGIN
    clear
    frm = coord_frame
    --copy data into class. A copy is made as data needs
    --to be sorted to be used in a kd tree
    COPY_PATH(kd_data, 0, 0, data, status)
    ret = build_tree(1, PATH_LEN(data), 0)
  END create

ROUTINE new_generator
  BEGIN
    reset_generator

    SELECT typ OF
      CASE(IN_ORDER):
        inorder(this.root)
      CASE(PRE_ORDER):
        preorder(this.root)
      CASE(POST_ORDER):
        postorder(this.root)
      ELSE:
    ENDSELECT
    
  END new_generator

ROUTINE next
  BEGIN
    current = current + 1
    RETURN(data[traverse[current].v])
  END next

ROUTINE print
  VAR
    i : INTEGER
    nde : KDTREE_DATA_TYPE
  BEGIN
    new_generator(typ)

    WRITE TPDISPLAY(CR)
    FOR i=1 TO PATH_LEN(traverse) DO
      nde = next
      user_print(nde)
      WRITE TPDISPLAY(CR)
    ENDFOR
  END print

ROUTINE print_query
  VAR
    i : INTEGER
    nde : KDTREE_DATA_TYPE
  BEGIN
    WRITE TPDISPLAY(CR)
    FOR i=1 TO PATH_LEN(query) DO
      WRITE('p[', query[i].idx, ']: ')
      user_print(data[query[i].idx])
      WRITE(' d: ', query[i].value::5::2)
      WRITE TPDISPLAY(CR)
    ENDFOR
  END print_query

ROUTINE copy_data
  VAR
    status : INTEGER
  BEGIN
    COPY_PATH(data, 0, 0, out_list, status)
  END copy_data

ROUTINE get_query
  VAR
    i, status : INTEGER
  BEGIN
    FOR i=1 TO PATH_LEN(query) DO
      APPEND_NODE(out_list, status)
      out_list[PATH_LEN(out_list)].KDTREE_NODE_NAME = data[query[i].idx].KDTREE_NODE_NAME
    ENDFOR
  END get_query

ROUTINE get_query_arr
  VAR
    i, status : INTEGER
  BEGIN
    IF ARRAY_LEN(out_arr) < PATH_LEN(query) THEN
      karelError(ARR_LEN_MISMATCH,'output array is not large enough to contain query', ER_ABORT)
    ENDIF

    FOR i=1 TO PATH_LEN(query) DO
      out_arr[i] = data[query[i].idx].KDTREE_NODE_NAME
    ENDFOR
  END get_query_arr

ROUTINE get_query_idx
  VAR
    i, status : INTEGER
  BEGIN
    IF ARRAY_LEN(out_idx) < PATH_LEN(query) THEN
      karelError(ARR_LEN_MISMATCH,'output array is not large enough to contain query', ER_ABORT)
    ENDIF

    FOR i=1 TO PATH_LEN(query) DO
      out_idx[i] = query[i]
    ENDFOR
  END get_query_idx

ROUTINE findmin
  BEGIN
    RETURN(data[minmaxUtil(this.root, 0, dimension, LESS_THAN)])
  END findmin

ROUTINE findmax
  BEGIN
    RETURN(data[minmaxUtil(this.root, 0, dimension, GREATER_THAN)])
  END findmax

ROUTINE kth_nearest_neighbors
  VAR
    i, status : INTEGER
  BEGIN
    clear_query
    --fill query with kth nodes. Set 1st index for insert
    FOR i=1 TO k DO
      APPEND_NODE(query, status)
      query[i].idx = 0
      query[i].value = 0
    ENDFOR
    query[1].value = KDTREE_MAX_DIST

    kNNUtil(this.root, 0, point)

  END kth_nearest_neighbors

ROUTINE kNN_brute_force
  VAR
    i,j : INTEGER
    status : INTEGER
    dist : KDTREE_COMPARE_TYPE
    inserted : BOOLEAN
  BEGIN
    clear_query
    --fill query with kth nodes. Set 1st index for insert
    FOR i=1 TO k DO
      APPEND_NODE(query, status)
      query[i].idx = 0
      query[i].value = 0
    ENDFOR
    query[1].value = KDTREE_MAX_DIST

    FOR i=1 TO PATH_LEN(data) DO
      dist = distance(point, data[i])
      -- append node to query list
      IF dist > 0 THEN
        j = 1
        inserted = FALSE
        WHILE((j<=PATH_LEN(query)) AND (NOT inserted)) DO
          IF dist < query[j].value THEN
            INSERT_NODE(query, j, status)
            query[j].idx = i
            query[j].value = dist
            DELETE_NODE(query, PATH_LEN(query), status)
            inserted = TRUE
          ENDIF
          j = j + 1
        ENDWHILE
      ENDIF
    ENDFOR

    -- return query
  END kNN_brute_force

ROUTINE radius_nearest_neighbors
  VAR
    i, status : INTEGER
  BEGIN
    clear_query
    
    APPEND_NODE(query, status)
    query[1].idx = 0
    query[1].value = KDTREE_MAX_DIST

    rNNUtil(this.root, 0, (radius), point)

    DELETE_NODE(query, PATH_LEN(query), status)

  END radius_nearest_neighbors

ROUTINE rNN_brute_force
  VAR
    i,j : INTEGER
    status : INTEGER
    dist : KDTREE_COMPARE_TYPE
    inserted : BOOLEAN
  BEGIN
    clear_query
    
    --dummy placement node
    APPEND_NODE(query, status)
    query[1].idx = 0
    query[1].value = KDTREE_MAX_DIST

    FOR i=1 TO PATH_LEN(data) DO
      dist = distance(point, data[i])
      -- append node to query list
      IF (dist < radius) AND (dist > 0) THEN
        j = 1
        inserted = FALSE
        WHILE((j<=PATH_LEN(query)) AND (NOT inserted)) DO
          IF dist < query[j].value THEN
            INSERT_NODE(query, j, status)
            query[j].idx = i
            query[j].value = dist
            inserted = TRUE
          ENDIF
          j = j + 1
        ENDWHILE
      ENDIF
    ENDFOR

    --remove last node, as it is only a dummy placement
    DELETE_NODE(query, PATH_LEN(query), status)
    
    -- return query

  END rNN_brute_force

BEGIN
END class_name